From 9369f37be1e1b6e1accca957aa362235ac16ffda Mon Sep 17 00:00:00 2001
From: Pritesh Patel <pritesh.patel@einfochips.com>
Date: Mon, 19 May 2025 14:52:01 +0000
Subject: [PATCH 5/5] lib: sbi: eic770x: Add PMP for TOR region

- Modify pmpcfg csr if TOR size is defined
- Added 'unsigned long tor' in sbi_domain_memregion_init
  to define size of TOR region.
- Set reg field of sbi_domain_memregion to set end size of TOR region
- Add PMP permission for memory which is of DIE1 and Reserved memory area
  to protect those memory regions from speculative access
- Removing PMP permission for PLIC memory regions as we are short of PMP regions
    0x000000000c200000-0x000000000c203fff M: (I,R,W) S/U: (R,W)
    0x000000000c000000-0x000000000c1fffff M: (I,R,W) S/U: (R,W)
- Removed PMP from UART driver as we are short of pmp regions and
  use this region to mask the range 0x20000000-0x3FFFFFFF

Upstream-Status: Pending

Co-developed-by: Pritesh Patel <pritesh.patel@einfochips.com>
Signed-off-by: Pritesh Patel <pritesh.patel@einfochips.com>
Signed-off-by: Darshan Prajapati <darshan.prajapati@einfochips.com>
Signed-off-by: Pinkesh Vaghela <pinkesh.vaghela@einfochips.com>
---
 include/sbi/sbi_domain.h    |  7 ++-
 lib/sbi/sbi_domain.c        | 44 ++++++++++++++---
 lib/sbi/sbi_hart.c          | 98 +++++++++++++++++++++++++++++++------
 lib/utils/fdt/fdt_domain.c  |  2 +-
 lib/utils/irqchip/plic.c    |  7 ++-
 lib/utils/serial/uart8250.c |  9 +++-
 6 files changed, 141 insertions(+), 26 deletions(-)

diff --git a/include/sbi/sbi_domain.h b/include/sbi/sbi_domain.h
index 8a2b123..fcc86fc 100644
--- a/include/sbi/sbi_domain.h
+++ b/include/sbi/sbi_domain.h
@@ -158,6 +158,9 @@ struct sbi_domain_memregion {
 
 #define SBI_DOMAIN_MEMREGION_MMIO		(1UL << 31)
 	unsigned long flags;
+	/** region for NAPOT(0) or TOR(size) */
+	unsigned long tor;
+
 };
 
 /** Representation of OpenSBI domain */
@@ -243,11 +246,13 @@ int sbi_domain_get_assigned_hartmask(const struct sbi_domain *dom,
  * @param size physical size of memory region
  * @param flags memory region flags
  * @param reg pointer to memory region being initialized
+ * @param tor 0:NAPOT , other:size of TOR; if use TOR mode, @size only used for region check
  */
 void sbi_domain_memregion_init(unsigned long addr,
 				unsigned long size,
 				unsigned long flags,
-				struct sbi_domain_memregion *reg);
+				struct sbi_domain_memregion *reg,
+				unsigned long tor);
 
 /**
  * Check whether we can access specified address for given mode and
diff --git a/lib/sbi/sbi_domain.c b/lib/sbi/sbi_domain.c
index 1cf7e2d..c612336 100644
--- a/lib/sbi/sbi_domain.c
+++ b/lib/sbi/sbi_domain.c
@@ -27,6 +27,10 @@ static bool domain_finalized = false;
 #define ROOT_REGION_MAX	32
 static u32 root_memregs_count = 0;
 
+#ifdef CONFIG_PLATFORM_ESWIN
+static struct sbi_domain_memregion root_hole_region;
+#endif
+
 struct sbi_domain root = {
 	.name = "root",
 	.possible_harts = NULL,
@@ -93,10 +97,21 @@ int sbi_domain_get_assigned_hartmask(const struct sbi_domain *dom,
 	return ret;
 }
 
+#ifdef CONFIG_PLATFORM_ESWIN
+static void domain_memregion_inithole(struct sbi_domain_memregion *reg)
+{
+       if (!reg)
+               return;
+
+       sbi_memcpy(reg, &root_hole_region, sizeof(*reg));
+}
+#endif
+
 void sbi_domain_memregion_init(unsigned long addr,
 				unsigned long size,
 				unsigned long flags,
-				struct sbi_domain_memregion *reg)
+				struct sbi_domain_memregion *reg,
+				unsigned long tor)
 {
 	unsigned long base = 0, order;
 
@@ -119,6 +134,7 @@ void sbi_domain_memregion_init(unsigned long addr,
 		reg->base = base;
 		reg->order = order;
 		reg->flags = flags;
+		reg->tor = tor;
 	}
 }
 
@@ -453,8 +469,12 @@ void sbi_domain_dump(const struct sbi_domain *dom, const char *suffix)
 	i = 0;
 	sbi_domain_for_each_memregion(dom, reg) {
 		rstart = reg->base;
-		rend = (reg->order < __riscv_xlen) ?
-			rstart + ((1UL << reg->order) - 1) : -1UL;
+		if (!reg->tor) {
+			rend = (reg->order < __riscv_xlen) ?
+				rstart + ((1UL << reg->order) - 1) : -1UL;
+		}else{
+			rend = rstart + reg->tor - 1;
+		}
 
 		sbi_printf("Domain%d Region%02d    %s: 0x%" PRILX "-0x%" PRILX " ",
 			   dom->index, i, suffix, rstart, rend);
@@ -675,7 +695,7 @@ int sbi_domain_root_add_memrange(unsigned long addr, unsigned long size,
 			rsize = ((end - pos) < align) ?
 				(end - pos) : align;
 
-		sbi_domain_memregion_init(pos, rsize, region_flags, &reg);
+		sbi_domain_memregion_init(pos, rsize, region_flags, &reg,0);
 		rc = root_add_memregion(&reg);
 		if (rc)
 			return rc;
@@ -805,13 +825,23 @@ int sbi_domain_init(struct sbi_scratch *scratch, u32 cold_hartid)
 	sbi_domain_memregion_init(scratch->fw_start, scratch->fw_rw_offset,
 				  (SBI_DOMAIN_MEMREGION_M_READABLE |
 				   SBI_DOMAIN_MEMREGION_M_EXECUTABLE),
-				  &root_memregs[root_memregs_count++]);
+				  &root_memregs[root_memregs_count++],0);
 
 	sbi_domain_memregion_init((scratch->fw_start + scratch->fw_rw_offset),
 				  (scratch->fw_size - scratch->fw_rw_offset),
 				  (SBI_DOMAIN_MEMREGION_M_READABLE |
 				   SBI_DOMAIN_MEMREGION_M_WRITABLE),
-				  &root_memregs[root_memregs_count++]);
+				  &root_memregs[root_memregs_count++],0);
+
+#ifdef CONFIG_PLATFORM_ESWIN
+	sbi_domain_memregion_init(0x20000000UL, 0x1fffffffUL, SBI_DOMAIN_MEMREGION_ENF_PERMISSIONS,
+				&root_hole_region,0);
+	domain_memregion_inithole(&root_memregs[root_memregs_count++]);
+
+	sbi_domain_memregion_init(0x1000000000UL, 0x3fffffUL, SBI_DOMAIN_MEMREGION_ENF_PERMISSIONS,
+				&root_hole_region,0x7000000000UL);
+	domain_memregion_inithole(&root_memregs[root_memregs_count++]);
+#endif
 
 	root.fw_region_inited = true;
 
@@ -826,7 +856,7 @@ int sbi_domain_init(struct sbi_scratch *scratch, u32 cold_hartid)
 				  (SBI_DOMAIN_MEMREGION_SU_READABLE |
 				   SBI_DOMAIN_MEMREGION_SU_WRITABLE |
 				   SBI_DOMAIN_MEMREGION_SU_EXECUTABLE),
-				  &root_memregs[root_memregs_count++]);
+				  &root_memregs[root_memregs_count++],0);
 
 	/* Root domain memory region end */
 	root_memregs[root_memregs_count].order = 0;
diff --git a/lib/sbi/sbi_hart.c b/lib/sbi/sbi_hart.c
index 39157a0..80675c5 100644
--- a/lib/sbi/sbi_hart.c
+++ b/lib/sbi/sbi_hart.c
@@ -288,6 +288,67 @@ unsigned int sbi_hart_mhpm_bits(struct sbi_scratch *scratch)
 	return hfeatures->mhpm_bits;
 }
 
+int pmp_set_tor(unsigned int n, unsigned long prot, unsigned long addr_start, unsigned long addr_end)
+{
+	/* PMP addresses are 4-byte aligned, drop the bottom two bits */
+	unsigned long protected_start = ((size_t) addr_start)>>2;
+	unsigned long protected_end = ((size_t) addr_end)>>2;
+	unsigned long cfgmask = 0xffff, pmpcfg;
+	int pmpcfg_csr, pmpcfg_shift, pmpaddr_csr;
+#define NAPOT_SIZE 4096
+	/* Clear the bit corresponding with alignment */
+	protected_start &= ~(NAPOT_SIZE >> 3);
+	protected_end &= ~(NAPOT_SIZE >> 3);
+
+	/* start region */
+#if __riscv_xlen == 32
+	pmpcfg_csr   = CSR_PMPCFG0 + (n >> 2);
+	pmpcfg_shift = (n & 3) << 3;
+#elif __riscv_xlen == 64
+	pmpcfg_csr   = (CSR_PMPCFG0 + (n >> 2)) & ~1;
+	pmpcfg_shift = (n & 7) << 3;
+#else
+	return SBI_ENOTSUPP;
+#endif
+	pmpaddr_csr = CSR_PMPADDR0 + n;
+
+	/* encode PMP config */
+	prot &= ~PMP_A;
+	cfgmask = ~(0xffUL << pmpcfg_shift);
+	pmpcfg  = (csr_read_num(pmpcfg_csr) & cfgmask);
+	pmpcfg |= ((prot << pmpcfg_shift) & ~cfgmask);
+
+	/* write csrs */
+	csr_write_num(pmpaddr_csr, protected_start);
+	csr_write_num(pmpcfg_csr, pmpcfg);
+
+	/* end region */
+	n++;
+#if __riscv_xlen == 32
+	pmpcfg_csr   = CSR_PMPCFG0 + (n >> 2);
+	pmpcfg_shift = (n & 3) << 3;
+#elif __riscv_xlen == 64
+	pmpcfg_csr   = (CSR_PMPCFG0 + (n >> 2)) & ~1;
+	pmpcfg_shift = (n & 7) << 3;
+#else
+	return SBI_ENOTSUPP;
+#endif
+	pmpaddr_csr = CSR_PMPADDR0 + n;
+
+	/* encode PMP config */
+	prot &= ~PMP_A;
+	prot |= PMP_A_TOR;
+	cfgmask = ~(0xffUL << pmpcfg_shift);
+	pmpcfg  = (csr_read_num(pmpcfg_csr) & cfgmask);
+	pmpcfg |= ((prot << pmpcfg_shift) & ~cfgmask);
+
+	/* write csrs */
+	csr_write_num(pmpaddr_csr, protected_end);
+	csr_write_num(pmpcfg_csr, pmpcfg);
+
+	return 0;
+}
+
 /*
  * Returns Smepmp flags for a given domain and region based on permissions.
  */
@@ -359,15 +420,19 @@ static void sbi_hart_smepmp_set(struct sbi_scratch *scratch,
 				unsigned int pmp_log2gran,
 				unsigned long pmp_addr_max)
 {
-	unsigned long pmp_addr = reg->base >> PMP_SHIFT;
 
-	if (pmp_log2gran <= reg->order && pmp_addr < pmp_addr_max) {
-		pmp_set(pmp_idx, pmp_flags, reg->base, reg->order);
+	if (!reg->tor) {
+		unsigned long pmp_addr = reg->base >> PMP_SHIFT;
+		if (pmp_log2gran <= reg->order && pmp_addr < pmp_addr_max)
+			pmp_set(pmp_idx++, pmp_flags, reg->base, reg->order);
+		else {
+			sbi_printf("Can not configure pmp for domain %s", dom->name);
+			sbi_printf(" because memory region address %lx or size %lx is not in range\n",
+				reg->base, reg->order);
+		}
 	} else {
-		sbi_printf("Can not configure pmp for domain %s because"
-			   " memory region address 0x%lx or size 0x%lx "
-			   "is not in range.\n", dom->name, reg->base,
-			   reg->order);
+		pmp_set_tor(pmp_idx, pmp_flags, reg->base, reg->base+reg->tor);
+		pmp_idx+=2;
 	}
 }
 
@@ -477,14 +542,19 @@ static int sbi_hart_oldpmp_configure(struct sbi_scratch *scratch,
 		if (reg->flags & SBI_DOMAIN_MEMREGION_SU_EXECUTABLE)
 			pmp_flags |= PMP_X;
 
-		pmp_addr = reg->base >> PMP_SHIFT;
-		if (pmp_log2gran <= reg->order && pmp_addr < pmp_addr_max) {
-			pmp_set(pmp_idx++, pmp_flags, reg->base, reg->order);
+		if (!reg->tor) {
+			pmp_addr =  reg->base >> PMP_SHIFT;
+			if (pmp_log2gran <= reg->order && pmp_addr < pmp_addr_max)
+				pmp_set(pmp_idx++, pmp_flags, reg->base, reg->order);
+			else {
+				sbi_printf("Can not configure pmp for domain %s", dom->name);
+				sbi_printf(" because memory region address %lx or size %lx is not in range\n",
+					reg->base, reg->order);
+			}
 		} else {
-			sbi_printf("Can not configure pmp for domain %s because"
-				   " memory region address 0x%lx or size 0x%lx "
-				   "is not in range.\n", dom->name, reg->base,
-				   reg->order);
+			pmp_addr =  reg->base;
+			pmp_set_tor(pmp_idx, pmp_flags, reg->base, reg->base+reg->tor);
+			pmp_idx+=2;
 		}
 	}
 
diff --git a/lib/utils/fdt/fdt_domain.c b/lib/utils/fdt/fdt_domain.c
index 4bc7ed8..1b52e13 100644
--- a/lib/utils/fdt/fdt_domain.c
+++ b/lib/utils/fdt/fdt_domain.c
@@ -295,7 +295,7 @@ static int __fdt_parse_region(const void *fdt, int domain_offset,
 		flags |= SBI_DOMAIN_MEMREGION_MMIO;
 
 	sbi_domain_memregion_init(base, (order == __riscv_xlen) ? ~0UL : BIT(order),
-				  flags, &preg->dom->regions[preg->region_count]);
+				  flags, &preg->dom->regions[preg->region_count],0);
 
 	preg->region_count++;
 
diff --git a/lib/utils/irqchip/plic.c b/lib/utils/irqchip/plic.c
index 8b2190f..e180693 100644
--- a/lib/utils/irqchip/plic.c
+++ b/lib/utils/irqchip/plic.c
@@ -222,7 +222,10 @@ static int plic_warm_irqchip_init(struct sbi_irqchip_device *dev)
 
 int plic_cold_irqchip_init(struct plic_data *plic)
 {
-	int i, ret;
+	int i;
+#ifndef CONFIG_PLATFORM_ESWIN
+	int ret;
+#endif
 
 	if (!plic)
 		return SBI_EINVAL;
@@ -264,11 +267,13 @@ int plic_cold_irqchip_init(struct plic_data *plic)
 
 	plic_delegate(plic);
 
+#ifndef CONFIG_PLATFORM_ESWIN
 	ret = sbi_domain_root_add_memrange(plic->addr, plic->size, BIT(20),
 					(SBI_DOMAIN_MEMREGION_MMIO |
 					 SBI_DOMAIN_MEMREGION_SHARED_SURW_MRW));
 	if (ret)
 		return ret;
+#endif
 
 	for (u32 i = 0; i <= sbi_scratch_last_hartindex(); i++) {
 		if (plic->context_map[i][PLIC_M_CONTEXT] < 0 &&
diff --git a/lib/utils/serial/uart8250.c b/lib/utils/serial/uart8250.c
index 1fe053f..b25d374 100644
--- a/lib/utils/serial/uart8250.c
+++ b/lib/utils/serial/uart8250.c
@@ -135,7 +135,12 @@ int uart8250_init(unsigned long base, u32 in_freq, u32 baudrate, u32 reg_shift,
 
 	sbi_console_set_device(&uart8250_console);
 
+#ifdef CONFIG_PLATFORM_ESWIN
+	/* For now, not adding memrange for UART as we are short of PMP regions */
+	return 0;
+#else
 	return sbi_domain_root_add_memrange(base, PAGE_SIZE, PAGE_SIZE,
-					    (SBI_DOMAIN_MEMREGION_MMIO |
-					    SBI_DOMAIN_MEMREGION_SHARED_SURW_MRW));
+			(SBI_DOMAIN_MEMREGION_MMIO |
+			 SBI_DOMAIN_MEMREGION_SHARED_SURW_MRW));
+#endif
 }
-- 
2.25.1

